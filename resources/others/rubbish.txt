package core.world.teleportation;

import org.eclipse.collections.api.list.MutableList;

public class NextLevelTpPoints {

	private MutableList<NextLevelTpPoint> teleports;

	public NextLevelTpPoints(MutableList<NextLevelTpPoint> teleports) {
		this.teleports = teleports;
	}
	
	
}



	private DirectedAnimationOnCall generateAnimation() {
		DirectedAnimationOnCall animation = new DirectedAnimationOnCall(); 
		animation.addDirTicksEntry(Direction.DOWN, 4);
		animation.addDirTicksEntry(Direction.LEFT, 4);
		animation.addDirTicksEntry(Direction.RIGHT, 4);
		animation.addDirTicksEntry(Direction.UP, 4);
		
		animation.addAnimationChunck(Direction.DOWN,
				Factory.mList(new AnimationFrame(getTexture(), 0, 0, 12, 13, 1.0f),
								new AnimationFrame(getTexture(), 13, 0, 12, 13, 1.0f)));
		animation.addAnimationChunck(Direction.LEFT,
				Factory.mList(new AnimationFrame(getTexture(), 26, 0, 12, 13, 1.0f),
								new AnimationFrame(getTexture(), 39, 0, 12, 13, 1.0f)));
		animation.addAnimationChunck(Direction.RIGHT,
				Factory.mList(new AnimationFrame(getTexture(), 52, 0, 8, 13, 1.0f),
								new AnimationFrame(getTexture(), 61, 0, 8, 13, 1.0f)));
		animation.addAnimationChunck(Direction.UP,
				Factory.mList(new AnimationFrame(getTexture(), 70, 0, 8, 13, 1.0f),
								new AnimationFrame(getTexture(), 79, 0, 8, 13, 1.0f)));
		
		return animation;
	}


		// private final static Logger INSTANCE = new Logger();
	
	private Logger() {}
	
	public static Logger get() {
		return INSTANCE;
	}


	//		switch(direction) {
//			case DOWN:
//				return (ts - w) >> 1;
//			case UP:
//				return (ts - w) >> 1;
//			case RIGHT:
//				(ts - w) >> 1;
//			case LEFT:
//				return 6;
//		default:
//			throw new IllegalStateException();
//		}




package rendering.animation;

import org.eclipse.collections.api.list.MutableList;

import rendering.Texture;

public class BasicAnimationOnTick extends BasicAnimation{

	protected BasicAnimationOnTick(int delay, MutableList<AnimationFrame> frames) {
		super(delay, frames);
	}

	@Override
	public void update() {
		tickCounter.increment();
		if(tickCounter.isStopped()) {
			++framePtr;
			tickCounter.reset();
		}
		
		if(framePtr >= framesCount)
			framePtr = 0;
	}
	
	public static Animation get(Texture spritesheet, int delay, float scale, int... framesData) {
		MutableList<AnimationFrame> frames = AnimationFrame.getFromData(spritesheet, scale, framesData);
		return new BasicAnimationOnTick(delay, frames);
	}
}

		// Logger.get().logn("Texture sizes: " + frameSheet.getWidth() + ", " + frameSheet.getHeight());
		// Logger.get().logn("Subimage on: " + startX + ", " + startY + ", " + width + ", " + height);

//		Texture s = Texture.ENERGY_SPRITESHEET;
//		return BasicAnimation.get(s, 12, 1.0f,
//				0, 0, 6, 9,
//				7, 0, 6, 9,
//				14, 0, 6, 9,
//				21, 0, 6, 9);

	public void setCurrentDirection(Direction direction) {
		Logger.log("Direction was " + this.direction);
		this.direction = direction;
		Logger.log(", is now: " + this.direction + "\n");
	}

package core.entities.projectiles;

import core.entities.Direction;
import core.entities.MoveStrategy;
import core.entities.enemies.Enemy;
import core.entities.walls.Wall;
import core.world.Tile;
import core.world.level.Level;
import rendering.animation.Animation;
import utils.AABB;
import utils.Config;

public class PlayerAnimatedProjectile extends AnimatedProjectile{

	private MoveStrategy moveStrategy;
	
	public PlayerAnimatedProjectile(Level level, Direction direction, Animation animation, int x, int y) {
		super(level, direction, animation, x, y);
		this.moveStrategy = new PlayerProjectileMoveStrategy(level.getPlayer(), animation);
	}

	@Override
	public void update() {
		move();
	}
	
	private void move() {
		AABB box = getBox();
		Enemy enemyCollision = level.enemyCollision(box);
		
		if(enemyCollision != null) {
			enemyCollision.die();
			die();
		} else {
			Wall wallCollision = level.wallCollision(box);
			if(wallCollision != null) {
				die();
				if(wallCollision.isDestructible()) {
					wallCollision.forget();
				}
			} else {
				Tile tile = getTile();
				if(tile == null || tile.isDoored()) {
					die();
					return;
				}
						
				x += dx;
				y += dy;
				
				if(x < 0 || x > Config.WIDTH || y < 0 || y > Config.HEIGHT) {
					die();
					return;
				}
				
				animation.update();
			}
		}
	}
	
}


package rendering.UI;

import java.awt.Color;

import core.Core;
import rendering.Screen;

public class LoadingScreen implements Runnable{

	private Core core;
	private ProgressBar progressBar;
	private Screen screen;
	// private boolean running;
	
	public LoadingScreen(Core core, Screen screen) {
		this.core = core;
		this.screen = screen;
		// this.running = false;
		this.progressBar = new ProgressBar(core);
	}
	
	public void start() {
		// this.running = true;
	}
	
	@Override
	public void run() {
		while(running) {
			screen.clear(Color.WHITE);
			screen.renderText("YO", 50, 50, 24.0f, Color.WHITE);
			screen.render();
		}
	}
}


        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();

        int w = core.getSize().width;
        int h = core.getSize().height;
        int x = (dim.width-w)/2;
        int y = (dim.height-h)/2;
        bar.setLocation(x, y);

//	public static World enablePortals(World world, String... levelFileNames) {
//		int lvlCount = world.getLevelCount();
//		
//		if (lvlCount > 1) {
//			for (int i = 0; i < lvlCount - 1; ++i) {
//				world.addPortal(levelFileNames[i], levelFileNames[i + 1]);
//			}
//		}
//		
//		return world;
//	}

--

package core.world.level;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import core.entities.player.Player;
import core.world.teleportation.Portal;
import core.world.teleportation.PortalSourcePoint;
import rendering.Screen;
import utils.exceptions.PowtakException;

public class LevelChunck {

	private Map<String, Level> levels;
	private Player player;
	private String idCurrent;
	private int levelsArrayIndex;
	private Level[] levelsArray;
	
	public LevelChunck(List<Level> inLevels) {
		this.levels = new HashMap<>();
		this.levelsArrayIndex = 0;
		this.idCurrent = levelsArray[levelsArrayIndex].getId();
		
		for(Level inLevel : inLevels) {
			this.levels.put(inLevel.getId(), inLevel);
			inLevel.setLevelChunck(this);
		}
		
		levelsArray = buildLevelsArray();
//		System.out.println(this.levels.get("level1"));
//		System.out.println(this.levels.get("level4"));
		this.player = new Player(levelsArray[levelsArrayIndex]);
	}
	
	public Level[] getLevelsArray() {
		return levelsArray;
	}
	
	public Level[] buildLevelsArray(){
		Level[] levels = new Level[count()];
		int i = 0;
		for(Level level : this.levels.values()) {
			levels[i++] = level;
		}
		return levels;
	}
	
	public void reload(Screen s, String levelId, PortalSourcePoint nextLevelPortalSourcePoint, Portal nextLevelPortal) throws PowtakException {
		Level reloadedLevel = Level.from(s, LevelLoader.get().loadCustomLevel(levelId));
		reloadedLevel.setLevelChunck(this);
		reloadedLevel.setNextLevelPortalSourcePoint(nextLevelPortalSourcePoint);
		reloadedLevel.setNextLevelPortal(nextLevelPortal);
		levels.put(levelId, reloadedLevel);
		player.setLevel(reloadedLevel);
	}
	
	public void render(Screen s) {
		getCurrent().render();
		player.render(s);
	}
	
	public void update() throws PowtakException {
		getCurrent().update();
		player.update();
	}
	
	public Level getCurrent() {
		// return levels.get(idCurrent);
		return levelsArray[levelsArrayIndex];
	}
	
	public Level get(String id) {
		return levels.get(id);
	}
	
	public Level get(int i) {
		return levelsArray[i];
	}
	
	public void grow() {
		this.levels.keySet().forEach(l -> System.out.println(l));
		++levelsArrayIndex;
		idCurrent = (String) this.levels.keySet().toArray()[levelsArrayIndex];
//		System.out.println(idCurrentPtr);
//		System.out.println(idCurrent);
	}
	
	public void decrease() {
		--levelsArrayIndex;
		idCurrent = (String) this.levels.keySet().toArray()[levelsArrayIndex];
	}
	
	public int count() {
		return levels.size();
	}
}


--

//	public static void createSwapLevelPortals(LevelChunck levelChunck, String lvlSrcId, String lvlDestId) throws PowtakException {
//		Level levelSrc = levelChunck.get(lvlSrcId);
//		Level levelDest = levelChunck.get(lvlDestId);
//		
//		if(levelSrc == null || levelDest == null)
//			throw new IllegalStateException();
//		
//		int x = levelSrc.getNextLevelPortalSourcePoint().getX();
//		int y = levelSrc.getNextLevelPortalSourcePoint().getY();
//		Tile tile = levelSrc.getMap().getNormTileAt(x, y);
//		
//		Portal nextLevelPortal = new Portal(tile, x, y,
//				levelDest, levelDest.getPlayerConfig().getX(), levelDest.getPlayerConfig().getY());
//		levelSrc.setNextLevelPortal(nextLevelPortal);
//	}

--


//	public LevelConfig load(String levelFileName) {
//		int rows = Config.NUM_ROWS;
//		int cols = Config.NUM_COLS;
//		BufferedImage tex = new BufferedImage(cols, rows, BufferedImage.TYPE_INT_ARGB);
//		
//		// tiles
//		Tile[][] tiles = new Tile[rows][cols];
//		
//		// walls
//		WallChunck wallChunk = new WallChunck();
//		
//		// key engine
//		DoorKeyEngine doorKeyEngine = new DoorKeyEngine();
//		
//		// player configuration
//		PlayerConfig playerConfig = new PlayerConfig();
//		
//		// teleportation to new level
//		NextLevelTpPointSource nextLevelTpPointSource = null;
//		
//		// enemies
//		EnemyChunck enemyChunck = new EnemyChunck();
//		
//		// energies
//		EnergyChunck energyChunck = new EnergyChunck();
//		
//		try {
//			tex = ImageIO.read(new FileInputStream(Utils.levelPath(levelFileName)));
//
//			for(int col = 0; col < cols; ++col) {
//				for(int row = 0; row < rows; ++row) {
//					int rgb = tex.getRGB(col, row);
//					int x = col * Config.TILE_SIZE;
//					int y = row * Config.TILE_SIZE;
//					
//					if(rgb == Config.GROUND_TILE_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//					}
//					
//					if(rgb == Config.STANDARD_WALL_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//						Wall wall = wallChunk.add(tiles[row][col], row, col, StandardWall.class);
//						tiles[row][col].setWall(wall);
//					}
//					
//					if(rgb == Config.DESTRUCTIBLE_WALL_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//						Wall wall = wallChunk.add(tiles[row][col], row, col, DestructibleWall.class);
//						tiles[row][col].setWall(wall);
//					}
//					
//					if(rgb == Config.NEXT_LEVEL_TELEPORT_POINT_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//						nextLevelTpPointSource = new NextLevelTpPointSource(x, y);
//						Log.info("Portal");
//					}
//					
//					if(Colors.isSpawn(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						playerConfig.setX(x);
//						playerConfig.setY(y);
//						playerConfig.setEnergy(Colors.green(rgb) - 155);
//						Direction playerDirection = Direction.NULL;
//						switch(Colors.red(rgb)) {
//						case 0:
//							playerDirection = Direction.DOWN;
//							break;
//						case 1:
//							playerDirection = Direction.LEFT;
//							break;
//						case 2:
//							playerDirection = Direction.UP;
//							break;
//						case 3:
//							playerDirection = Direction.RIGHT;
//							break;
//						default:
//							throw new IllegalStateException();
//						}
//						
//						playerConfig.setDirection(playerDirection);
//					}
//					
//					if(Colors.isZombie(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						Direction zomDir;
//						
//						switch(Colors.blue(rgb)) {
//							case 0:
//								zomDir = Direction.DOWN;
//								break;
//							case 1:
//								zomDir = Direction.LEFT;
//								break;
//							case 2:
//								zomDir = Direction.UP;
//								break;
//							case 3:
//								zomDir = Direction.RIGHT;
//								break;
//							default:
//								throw new IllegalStateException();
//						}
//						
//						enemyChunck.add(new StaticZombie(tiles[row][col], enemyChunck, x, y, 1.0f, zomDir));
//						Log.info("Zombie");
//					}
//					
//					if(Colors.isDoor(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						doorKeyEngine.addDoor(tiles[row][col], Colors.green(rgb));
//						Log.info("Door");
//					}
//					
//					if(Colors.isKey(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						doorKeyEngine.addKey(tiles[row][col], Colors.blue(rgb));
//						Log.info("Key");
//					}
//					
//					if(Colors.isEnergy(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						int energyAmount = Energy.retrievePower(rgb);
//						energyChunck.add(new Energy(tiles[row][col], x, y, energyAmount, energyChunck));
//						Log.info("Energy");
//					}
//				}
//			}
//			
//			doorKeyEngine.setReady();
//			return new LevelConfig(levelFileName, rows, cols, tiles, wallChunk, doorKeyEngine, playerConfig, nextLevelTpPointSource, enemyChunck, energyChunck);
//			
//		} catch (IOException e) {
//			e.printStackTrace();
//			throw new IllegalStateException();
//		}
//	}