package core.world.teleportation;

import org.eclipse.collections.api.list.MutableList;

public class NextLevelTpPoints {

	private MutableList<NextLevelTpPoint> teleports;

	public NextLevelTpPoints(MutableList<NextLevelTpPoint> teleports) {
		this.teleports = teleports;
	}
	
	
}



	private DirectedAnimationOnCall generateAnimation() {
		DirectedAnimationOnCall animation = new DirectedAnimationOnCall(); 
		animation.addDirTicksEntry(Direction.DOWN, 4);
		animation.addDirTicksEntry(Direction.LEFT, 4);
		animation.addDirTicksEntry(Direction.RIGHT, 4);
		animation.addDirTicksEntry(Direction.UP, 4);
		
		animation.addAnimationChunck(Direction.DOWN,
				Factory.mList(new AnimationFrame(getTexture(), 0, 0, 12, 13, 1.0f),
								new AnimationFrame(getTexture(), 13, 0, 12, 13, 1.0f)));
		animation.addAnimationChunck(Direction.LEFT,
				Factory.mList(new AnimationFrame(getTexture(), 26, 0, 12, 13, 1.0f),
								new AnimationFrame(getTexture(), 39, 0, 12, 13, 1.0f)));
		animation.addAnimationChunck(Direction.RIGHT,
				Factory.mList(new AnimationFrame(getTexture(), 52, 0, 8, 13, 1.0f),
								new AnimationFrame(getTexture(), 61, 0, 8, 13, 1.0f)));
		animation.addAnimationChunck(Direction.UP,
				Factory.mList(new AnimationFrame(getTexture(), 70, 0, 8, 13, 1.0f),
								new AnimationFrame(getTexture(), 79, 0, 8, 13, 1.0f)));
		
		return animation;
	}


		// private final static Logger INSTANCE = new Logger();
	
	private Logger() {}
	
	public static Logger get() {
		return INSTANCE;
	}


	//		switch(direction) {
//			case DOWN:
//				return (ts - w) >> 1;
//			case UP:
//				return (ts - w) >> 1;
//			case RIGHT:
//				(ts - w) >> 1;
//			case LEFT:
//				return 6;
//		default:
//			throw new IllegalStateException();
//		}




package rendering.animation;

import org.eclipse.collections.api.list.MutableList;

import rendering.Texture;

public class BasicAnimationOnTick extends BasicAnimation{

	protected BasicAnimationOnTick(int delay, MutableList<AnimationFrame> frames) {
		super(delay, frames);
	}

	@Override
	public void update() {
		tickCounter.increment();
		if(tickCounter.isStopped()) {
			++framePtr;
			tickCounter.reset();
		}
		
		if(framePtr >= framesCount)
			framePtr = 0;
	}
	
	public static Animation get(Texture spritesheet, int delay, float scale, int... framesData) {
		MutableList<AnimationFrame> frames = AnimationFrame.getFromData(spritesheet, scale, framesData);
		return new BasicAnimationOnTick(delay, frames);
	}
}

		// Logger.get().logn("Texture sizes: " + frameSheet.getWidth() + ", " + frameSheet.getHeight());
		// Logger.get().logn("Subimage on: " + startX + ", " + startY + ", " + width + ", " + height);

//		Texture s = Texture.ENERGY_SPRITESHEET;
//		return BasicAnimation.get(s, 12, 1.0f,
//				0, 0, 6, 9,
//				7, 0, 6, 9,
//				14, 0, 6, 9,
//				21, 0, 6, 9);

	public void setCurrentDirection(Direction direction) {
		Logger.log("Direction was " + this.direction);
		this.direction = direction;
		Logger.log(", is now: " + this.direction + "\n");
	}

package core.entities.projectiles;

import core.entities.Direction;
import core.entities.MoveStrategy;
import core.entities.enemies.Enemy;
import core.entities.walls.Wall;
import core.world.Tile;
import core.world.level.Level;
import rendering.animation.Animation;
import utils.AABB;
import utils.Config;

public class PlayerAnimatedProjectile extends AnimatedProjectile{

	private MoveStrategy moveStrategy;
	
	public PlayerAnimatedProjectile(Level level, Direction direction, Animation animation, int x, int y) {
		super(level, direction, animation, x, y);
		this.moveStrategy = new PlayerProjectileMoveStrategy(level.getPlayer(), animation);
	}

	@Override
	public void update() {
		move();
	}
	
	private void move() {
		AABB box = getBox();
		Enemy enemyCollision = level.enemyCollision(box);
		
		if(enemyCollision != null) {
			enemyCollision.die();
			die();
		} else {
			Wall wallCollision = level.wallCollision(box);
			if(wallCollision != null) {
				die();
				if(wallCollision.isDestructible()) {
					wallCollision.forget();
				}
			} else {
				Tile tile = getTile();
				if(tile == null || tile.isDoored()) {
					die();
					return;
				}
						
				x += dx;
				y += dy;
				
				if(x < 0 || x > Config.WIDTH || y < 0 || y > Config.HEIGHT) {
					die();
					return;
				}
				
				animation.update();
			}
		}
	}
	
}


package rendering.UI;

import java.awt.Color;

import core.Core;
import rendering.Screen;

public class LoadingScreen implements Runnable{

	private Core core;
	private ProgressBar progressBar;
	private Screen screen;
	// private boolean running;
	
	public LoadingScreen(Core core, Screen screen) {
		this.core = core;
		this.screen = screen;
		// this.running = false;
		this.progressBar = new ProgressBar(core);
	}
	
	public void start() {
		// this.running = true;
	}
	
	@Override
	public void run() {
		while(running) {
			screen.clear(Color.WHITE);
			screen.renderText("YO", 50, 50, 24.0f, Color.WHITE);
			screen.render();
		}
	}
}


        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();

        int w = core.getSize().width;
        int h = core.getSize().height;
        int x = (dim.width-w)/2;
        int y = (dim.height-h)/2;
        bar.setLocation(x, y);

//	public static World enablePortals(World world, String... levelFileNames) {
//		int lvlCount = world.getLevelCount();
//		
//		if (lvlCount > 1) {
//			for (int i = 0; i < lvlCount - 1; ++i) {
//				world.addPortal(levelFileNames[i], levelFileNames[i + 1]);
//			}
//		}
//		
//		return world;
//	}

--

package core.world.level;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import core.entities.player.Player;
import core.world.teleportation.Portal;
import core.world.teleportation.PortalSourcePoint;
import rendering.Screen;
import utils.exceptions.PowtakException;

public class LevelChunck {

	private Map<String, Level> levels;
	private Player player;
	private String idCurrent;
	private int levelsArrayIndex;
	private Level[] levelsArray;
	
	public LevelChunck(List<Level> inLevels) {
		this.levels = new HashMap<>();
		this.levelsArrayIndex = 0;
		this.idCurrent = levelsArray[levelsArrayIndex].getId();
		
		for(Level inLevel : inLevels) {
			this.levels.put(inLevel.getId(), inLevel);
			inLevel.setLevelChunck(this);
		}
		
		levelsArray = buildLevelsArray();
//		System.out.println(this.levels.get("level1"));
//		System.out.println(this.levels.get("level4"));
		this.player = new Player(levelsArray[levelsArrayIndex]);
	}
	
	public Level[] getLevelsArray() {
		return levelsArray;
	}
	
	public Level[] buildLevelsArray(){
		Level[] levels = new Level[count()];
		int i = 0;
		for(Level level : this.levels.values()) {
			levels[i++] = level;
		}
		return levels;
	}
	
	public void reload(Screen s, String levelId, PortalSourcePoint nextLevelPortalSourcePoint, Portal nextLevelPortal) throws PowtakException {
		Level reloadedLevel = Level.from(s, LevelLoader.get().loadCustomLevel(levelId));
		reloadedLevel.setLevelChunck(this);
		reloadedLevel.setNextLevelPortalSourcePoint(nextLevelPortalSourcePoint);
		reloadedLevel.setNextLevelPortal(nextLevelPortal);
		levels.put(levelId, reloadedLevel);
		player.setLevel(reloadedLevel);
	}
	
	public void render(Screen s) {
		getCurrent().render();
		player.render(s);
	}
	
	public void update() throws PowtakException {
		getCurrent().update();
		player.update();
	}
	
	public Level getCurrent() {
		// return levels.get(idCurrent);
		return levelsArray[levelsArrayIndex];
	}
	
	public Level get(String id) {
		return levels.get(id);
	}
	
	public Level get(int i) {
		return levelsArray[i];
	}
	
	public void grow() {
		this.levels.keySet().forEach(l -> System.out.println(l));
		++levelsArrayIndex;
		idCurrent = (String) this.levels.keySet().toArray()[levelsArrayIndex];
//		System.out.println(idCurrentPtr);
//		System.out.println(idCurrent);
	}
	
	public void decrease() {
		--levelsArrayIndex;
		idCurrent = (String) this.levels.keySet().toArray()[levelsArrayIndex];
	}
	
	public int count() {
		return levels.size();
	}
}


--

//	public static void createSwapLevelPortals(LevelChunck levelChunck, String lvlSrcId, String lvlDestId) throws PowtakException {
//		Level levelSrc = levelChunck.get(lvlSrcId);
//		Level levelDest = levelChunck.get(lvlDestId);
//		
//		if(levelSrc == null || levelDest == null)
//			throw new IllegalStateException();
//		
//		int x = levelSrc.getNextLevelPortalSourcePoint().getX();
//		int y = levelSrc.getNextLevelPortalSourcePoint().getY();
//		Tile tile = levelSrc.getMap().getNormTileAt(x, y);
//		
//		Portal nextLevelPortal = new Portal(tile, x, y,
//				levelDest, levelDest.getPlayerConfig().getX(), levelDest.getPlayerConfig().getY());
//		levelSrc.setNextLevelPortal(nextLevelPortal);
//	}

--


//	public LevelConfig load(String levelFileName) {
//		int rows = Config.NUM_ROWS;
//		int cols = Config.NUM_COLS;
//		BufferedImage tex = new BufferedImage(cols, rows, BufferedImage.TYPE_INT_ARGB);
//		
//		// tiles
//		Tile[][] tiles = new Tile[rows][cols];
//		
//		// walls
//		WallChunck wallChunk = new WallChunck();
//		
//		// key engine
//		DoorKeyEngine doorKeyEngine = new DoorKeyEngine();
//		
//		// player configuration
//		PlayerConfig playerConfig = new PlayerConfig();
//		
//		// teleportation to new level
//		NextLevelTpPointSource nextLevelTpPointSource = null;
//		
//		// enemies
//		EnemyChunck enemyChunck = new EnemyChunck();
//		
//		// energies
//		EnergyChunck energyChunck = new EnergyChunck();
//		
//		try {
//			tex = ImageIO.read(new FileInputStream(Utils.levelPath(levelFileName)));
//
//			for(int col = 0; col < cols; ++col) {
//				for(int row = 0; row < rows; ++row) {
//					int rgb = tex.getRGB(col, row);
//					int x = col * Config.TILE_SIZE;
//					int y = row * Config.TILE_SIZE;
//					
//					if(rgb == Config.GROUND_TILE_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//					}
//					
//					if(rgb == Config.STANDARD_WALL_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//						Wall wall = wallChunk.add(tiles[row][col], row, col, StandardWall.class);
//						tiles[row][col].setWall(wall);
//					}
//					
//					if(rgb == Config.DESTRUCTIBLE_WALL_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//						Wall wall = wallChunk.add(tiles[row][col], row, col, DestructibleWall.class);
//						tiles[row][col].setWall(wall);
//					}
//					
//					if(rgb == Config.NEXT_LEVEL_TELEPORT_POINT_COLOR.getRGB()) {
//						tiles[row][col] = new GroundTile(x, y);
//						nextLevelTpPointSource = new NextLevelTpPointSource(x, y);
//						Log.info("Portal");
//					}
//					
//					if(Colors.isSpawn(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						playerConfig.setX(x);
//						playerConfig.setY(y);
//						playerConfig.setEnergy(Colors.green(rgb) - 155);
//						Direction playerDirection = Direction.NULL;
//						switch(Colors.red(rgb)) {
//						case 0:
//							playerDirection = Direction.DOWN;
//							break;
//						case 1:
//							playerDirection = Direction.LEFT;
//							break;
//						case 2:
//							playerDirection = Direction.UP;
//							break;
//						case 3:
//							playerDirection = Direction.RIGHT;
//							break;
//						default:
//							throw new IllegalStateException();
//						}
//						
//						playerConfig.setDirection(playerDirection);
//					}
//					
//					if(Colors.isZombie(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						Direction zomDir;
//						
//						switch(Colors.blue(rgb)) {
//							case 0:
//								zomDir = Direction.DOWN;
//								break;
//							case 1:
//								zomDir = Direction.LEFT;
//								break;
//							case 2:
//								zomDir = Direction.UP;
//								break;
//							case 3:
//								zomDir = Direction.RIGHT;
//								break;
//							default:
//								throw new IllegalStateException();
//						}
//						
//						enemyChunck.add(new StaticZombie(tiles[row][col], enemyChunck, x, y, 1.0f, zomDir));
//						Log.info("Zombie");
//					}
//					
//					if(Colors.isDoor(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						doorKeyEngine.addDoor(tiles[row][col], Colors.green(rgb));
//						Log.info("Door");
//					}
//					
//					if(Colors.isKey(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						doorKeyEngine.addKey(tiles[row][col], Colors.blue(rgb));
//						Log.info("Key");
//					}
//					
//					if(Colors.isEnergy(rgb)) {
//						tiles[row][col] = new GroundTile(x, y);
//						int energyAmount = Energy.retrievePower(rgb);
//						energyChunck.add(new Energy(tiles[row][col], x, y, energyAmount, energyChunck));
//						Log.info("Energy");
//					}
//				}
//			}
//			
//			doorKeyEngine.setReady();
//			return new LevelConfig(levelFileName, rows, cols, tiles, wallChunk, doorKeyEngine, playerConfig, nextLevelTpPointSource, enemyChunck, energyChunck);
//			
//		} catch (IOException e) {
//			e.printStackTrace();
//			throw new IllegalStateException();
//		}
//	}

--

	private LightChunck buildLightChunck() {
		LightChunck lightChunck = new LightChunck();
		lightChunck.add(new LightSpot(s, 0, 96, Config.TILE_SIZE, Color.CYAN));
		lightChunck.add(new LightSpot(s, 32, 96, Config.TILE_SIZE, Color.MAGENTA));
		lightChunck.add(new LightSpot(s, 64, 96, Config.TILE_SIZE, Color.GREEN));
		lightChunck.add(new LightSpot(s, 96, 96, Config.TILE_SIZE, Color.WHITE));
		return lightChunck;
	}
	
	private ParticleEngine buildParticleEngine() {
		ParticleEngine particleEngine = ParticleEngine.empty();
//		List<Particle> particles = new ArrayList<>();
//		particles.add(new Particle(this, particleEngine, 0, 100, 100, new ParticleMovement(100, 100, 25, 25), new ExplosionAnimation(4, 1.0f)));
//		particles.add(new Particle(this, particleEngine, 0, 100, 100, new ParticleMovement(100, 100, 25, -25), new ExplosionAnimation(4, 1.0f)));
//		particles.add(new Particle(this, particleEngine, 0, 100, 100, new ParticleMovement(100, 100, -25, 25), new ExplosionAnimation(4, 1.0f)));
//		particles.add(new Particle(this, particleEngine, 0, 100, 100, new ParticleMovement(100, 100, -25, -25), new ExplosionAnimation(4, 1.0f)));
//		particleEngine.addComponent(particles);
		return particleEngine;
	}

	--

		public static Color of(ColorBundle colorBundle) {
		return new Color(colorBundle.r(), colorBundle.g(), colorBundle.b());
	}
	
	public static int increase(int rgb, Color color, float brightness) {
		return extract(rgb).increase(color, brightness).rgb();
	}


	// key when:
	// 	- red: 255  
	// 	- green: 255 
	// 	- blue: < 100
	public static boolean isKey(int rgb) {
		ColorBundle cBundle = extract(rgb);
		int r = cBundle.r();
		int g = cBundle.g();
		int b = cBundle.b();
		
		// 100 keys available
		return r == 255 && g == 255 && b >= 0 && b < 100;
	}
	
	// door when:
	// 	- red: 0
	// 	- green < 100
	// 	- blue: 255
	public static boolean isDoor(int rgb) {
		ColorBundle cBundle = extract(rgb);
		int r = cBundle.r();
		int g = cBundle.g();
		int b = cBundle.b();
		
		// 100 doors available
		return r == 0 && g >= 0 && g < 100 && b == 255;
	}
	
	// energy when:
	// 	- red: 255
	// 	- green < 100
	// 	- blue: 255
	public static boolean isEnergy(int rgb) {
		ColorBundle cBundle = extract(rgb);
		int r = cBundle.r();
		int g = cBundle.g();
		int b = cBundle.b();
		
		// 0 to 100 power amount
		return r == 255 && g >= 0 && g < 100 && b == 255;
	}
	
	// zombie when:
	// 	- red: 255
	// 	- green: 0
	// 	- blue < 4 ; 0 up ; 1 right ; 2 down ; 3 left
	public static boolean isZombie(int rgb) {
		ColorBundle cBundle = extract(rgb);
		int r = cBundle.r();
		int g = cBundle.g();
		int b = cBundle.b();
		return r == 255 && g == 0 && b >= 0 && b <= 3;
	}
	
	// spawn when:
	// 	- red: 0
	// 	- green >= 155
	// 	- blue: 0
	public static boolean isSpawn(int rgb) {
		ColorBundle cBundle = extract(rgb);
		int r = cBundle.r();
		int g = cBundle.g();
		int b = cBundle.b();
		// value of green significates value of initial energy
		return r >= 0 && r <= 3 && b == 0 && g >= 155 && g <= 255;
	}


	public static class ColorBundle{
		
		private int r;
		private int g;
		private int b;
		
		public ColorBundle(int r, int g, int b) {
			this.r = r;
			this.g = g;
			this.b = b;
		}
		
		public ColorBundle increase(Color color, float brightness) {
			r += (int) (color.getRed() * brightness);
			g += (int) (color.getGreen() * brightness);
			b += (int) (color.getBlue() * brightness);
			computeBounds();
			return this;
		}
		
		public ColorBundle increase(int dr, int dg, int db, float brightness) {
			r += (int) (dr * brightness);
			g += (int) (dg * brightness);
			b += (int) (db * brightness);
			computeBounds();
			return this;
		}
		
		public ColorBundle decrease(int dr, int dg, int db, float brightness) {
			r -= (int) (dr * brightness);
			g -= (int) (dg * brightness);
			b -= (int) (db * brightness);
			computeBounds();
			return this;
		}
		
		public ColorBundle computeBounds() {
			if(r < 0) r = 0;
			if(g < 0) g = 0;
			if(b < 0) b = 0;
			if(r > 255) r = 255;
			if(g > 255) g = 255;
			if(b > 255) b = 255;
			
			return this;
		}
		
		public int rgb() {
			computeBounds();
			return new Color(r, g, b).getRGB();
		}

		public int r() {
			return r;
		}

		public int g() {
			return g;
		}

		public int b() {
			return b;
		}
		
	}

	--

	package core.world.light;

import java.awt.Color;
import java.awt.image.BufferedImage;

import rendering.Screen;
import utils.Colors;
import utils.Colors.ColorBundle;

public class LightEngine {

	private final static LightEngine INSTANCE = new LightEngine();
	
	private LightEngine() {}
	
	public static LightEngine get() {
		return INSTANCE;
	}
	
	public void enlight(Screen screen, int sx, int sy, int w, int h, int color, float brightness, LightHint lhint) {
		if(lhint == LightHint.ELLIPSE) {
			eenlight(screen, sx, sy, w, h, color, brightness);
		} else {
			renlight(screen, sx, sy, w, h, color, brightness);
		}
	}
	
	private void eenlight(Screen screen, int sx, int sy, int w, int h, int color, float brightness) {
		renlight(screen, sx, sy, w, h, color, brightness);
	}
	
	private void renlight(Screen screen, int sx, int sy, int w, int h, int color, float brightness) {
		BufferedImage sdata = screen.getData();
		
		for(int x = sx; x < sx + w; ++x) {
			for(int y = sy; y < sy + h; ++y) {
				sdata.setRGB(x, y, enlight(sdata.getRGB(x, y), color, brightness));
			}
		}
	}
	
	private int enlight(int rgb, int color, float brightness) {
		ColorBundle rgbBundle = Colors.extract(rgb);
		ColorBundle colorBundle = Colors.extract(color);
		int dr = colorBundle.r();
		int dg = colorBundle.g();
		int db = colorBundle.b();
		
		return Colors.of(rgbBundle.increase(dr, dg, db, brightness)).getRGB();
	}
	
	public void darken(Screen screen, int sx, int sy, int w, int h, int color, float brightness, LightHint lhint) {
		BufferedImage sdata = screen.getData();
		
		for(int x = sx; x < sx + w; ++x) {
			for(int y = sy; y < sy + h; ++y) {
				sdata.setRGB(x, y, darken(sdata.getRGB(x, y), color, brightness));
			}
		}
	}
	
	private int darken(int rgb, int color, float brightness) {
		ColorBundle rgbBundle = Colors.extract(rgb);
		ColorBundle colorBundle = Colors.extract(color);
		int dr = colorBundle.r();
		int dg = colorBundle.g();
		int db = colorBundle.b();
		
		return Colors.of(rgbBundle.decrease(dr, dg, db, brightness)).getRGB();
	}
	
	public void darkenScreen(Screen screen, int power) {
		BufferedImage sdata = screen.getData();
		int w = sdata.getWidth();
		int h = sdata.getHeight();
		int blackRGB = Color.BLACK.getRGB();
		
		for(int x = 0; x < w; ++x) {
			for(int y = 0; y < h; ++y) {
				int rgb = sdata.getRGB(x, y);
				sdata.setRGB(x, y, Colors.decrease(rgb, blackRGB, power).getRGB());
//				int r = Colors.red(rgb) - power;
//				int g = Colors.green(rgb) - power;
//				int b = Colors.blue(rgb) - power;
//				if(r < 0) r = 0;
//				if(g < 0) g = 0;
//				if(b < 0) b = 0;
//				sdata.setRGB(x, y, Colors.of(new ColorBundle(r, g, b)).getRGB());
			}
		}
	}
	
}
--

package core.world.light;

import java.awt.Color;

import rendering.Screen;

public class LightSpot{

	private Color color;
	private Screen screen;
	private int x;
	private int y;
	private int radius;
	
	public LightSpot(Screen screen, int x, int y, int radius, Color color) {
		this.color = color;
		this.screen = screen;
		this.x = x;
		this.y = y;
		this.radius = radius;
	}
	
	public void enlight(float brightness) {
		screen.enlight(x, y, radius, radius, color.getRGB(), brightness);
	}
	
	public void darken(float brightness) {
		screen.darken(x, y, radius, radius, color.getRGB(), brightness);
	}

}

--

package core.world.light;

import java.util.ArrayList;
import java.util.List;

public class LightChunck {
	
	private List<LightSpot> lights;
	
	public LightChunck() {
		super();
		lights = new ArrayList<>();
	}
	
	public LightChunck add(LightSpot lightSpot) {
		lights.add(lightSpot);
		return this;
	}

	public LightChunck(List<LightSpot> lights) {
		this.lights = lights;
	}

	public static LightChunck of(List<LightSpot> lights) {
		return new LightChunck(lights);
	}

	public void enlight(float brightness) {
		lights.forEach(light -> light.enlight(brightness));
	}

	public void darken(float brightness) {
		lights.forEach(light -> light.darken(brightness));
	}

}
--

//				int r = Colors.red(rgb) - power;
//				int g = Colors.green(rgb) - power;
//				int b = Colors.blue(rgb) - power;
//				if(r < 0) r = 0;
//				if(g < 0) g = 0;
//				if(b < 0) b = 0;
//				sdata.setRGB(x, y, Colors.of(new ColorBundle(r, g, b)).getRGB());

--


	public void enlight(int sx, int sy, int w, int h, int color, float brightness) {
		LightEngine.get().enlight(this, sx, sy, w, h, color, brightness);
	}
	
	public void darken(int sx, int sy, int w, int h, int color, float brightness) {
		LightEngine.get().darken(this, sx, sy, w, h, color, brightness);
	}
	
	public void darken(float brightness) {
		darken(0, 0, Config.WIDTH, Config.HEIGHT, Color.WHITE.getRGB(), brightness, LightHint.RECTANGLE);
	}

	--

		float DarkenValue = 0.1f;
	float ddv = 0.1f;
	TickCounter darkenCounter = new TickCounter(Config.UPS >> 1);
	
	public void update() {
		darkenCounter.increment();
		if(darkenCounter.isStopped()) {
			DarkenValue += ddv;
			darkenCounter.reset();
			if(DarkenValue <= 0.0f || DarkenValue >= 0.8f) {
				ddv = -ddv;
			}
		}
	}